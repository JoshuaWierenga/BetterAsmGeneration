#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AsmGenerator;

[Generator]
public class AsmGenerator : ISourceGenerator
{
    private const string AsmStructures = @"
//<auto-generated />
using Iced.Intel;

namespace AsmGeneration
{
    public readonly struct BetterInstruction
    {
        private readonly Mnemonic _instruction;

        internal BetterInstruction(Mnemonic instruction)
        {
            _instruction = instruction;
        }

        public override string ToString()
        {
            return Enum.GetName(typeof(Mnemonic), _instruction) ?? ""Unknown Instruction"";
        }
    }

    internal enum AssemblyDataType : byte
    {
        Instruction,
        Operand
    }

    public struct AssemblyData
    {
        internal AssemblyDataType Type;

        internal BetterInstruction Instruction;

        internal Register Operand;

        public static implicit operator AssemblyData(BetterInstruction instruction) =>
            new()
            {
                Type = AssemblyDataType.Instruction,
                Instruction = instruction
            };

        public static implicit operator AssemblyData(AssemblerRegister64 r64) =>
            new()
            {
                Type = AssemblyDataType.Operand,
                Operand = r64
            };

        public override string ToString()
        {
            if (Type == AssemblyDataType.Instruction)
            {
                return Instruction.ToString();
            }

            if (Operand != Register.None)
            {
                return Operand.ToString();
            }

            throw new ArgumentOutOfRangeException();
        }
    }
}
";

    private const string AsmGeneratorStub = @"
//<auto-generated />
using Iced.Intel;
using BetterAsm;

namespace AsmGeneration
{
    internal static class CompileTimeBetterInstructionCollection
    {
        public static Assembler Parse(params AssemblyData[] assembly)
        {
            // This will be filled in by the generator once you call 
            throw new Exception(""This shouldn't be possible."");
        }
    }
}
";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
        {
            throw new InvalidOperationException("We were given the wrong syntax receiver.");
        }

        List<SyntaxNode> assemblerParseCalls = syntaxReceiver.AssemblerParseCalls;

        IEnumerable<AsmGenerationInfo> asmGenerationInfos =
            GetAsmGenerationInfo(context.Compilation, assemblerParseCalls);

        if (asmGenerationInfos.Any())
        {
            StringBuilder sb = new();
            GenerateAsmConverter(context, sb, asmGenerationInfos);

            context.AddSource("AsmConverter.cs", sb.ToString());
        }
        else
        {
            context.AddSource("AsmConverter.cs", AsmGeneratorStub);
        }

        //TODO Remove BetterAsm and migrate required structs into this project
        //context.AddSource("AsmStructures.cs", AsmStructures);
    }

    private static IEnumerable<AsmGenerationInfo> GetAsmGenerationInfo(Compilation compilation,
        List<SyntaxNode> assemblerParseCalls)
    {
        foreach (SyntaxNode assemblerParseCall in assemblerParseCalls)
        {
            //TODO Use data outside of invocation.ArgumentList or just return that from SyntaxReceiver
            InvocationExpressionSyntax invocation = (InvocationExpressionSyntax)assemblerParseCall;
            SemanticModel semanticModel = compilation.GetSemanticModel(invocation.ArgumentList.SyntaxTree);

            List<Tuple<string, List<string>>> instructionData = new(); 

            //TODO Remove
            //Debugger.Launch();

            foreach (ArgumentSyntax argument in invocation.ArgumentList.Arguments)
            {
                ExpressionSyntax asmData = argument.Expression;
                ITypeSymbol? typeSymbol = semanticModel.GetTypeInfo(asmData).Type;
                string asmLabel = ((IdentifierNameSyntax)asmData).Identifier.ValueText.ToLower();

                if (typeSymbol?.Name == "BetterInstruction")
                {
                    instructionData.Add(new Tuple<string, List<string>>(asmLabel, new List<string>()));
                }
                else if (instructionData.Count > 0)
                {
                    instructionData.Last().Item2.Add(asmLabel);
                }
                else
                {
                    //TODO Tidy!
                    throw new Exception();
                }
            }

            yield return new AsmGenerationInfo(instructionData);
        }
    }

    private static void GenerateAsmConverter(GeneratorExecutionContext context, StringBuilder sb,
        IEnumerable<AsmGenerationInfo> asmGenerationInfos)
    {
        const string indent = "        ";

        sb.AppendLine(
@" // <auto-generated />
using BetterAsm;
using Iced.Intel;
using static Iced.Intel.AssemblerRegisters;

namespace AsmGeneration
{
    internal static class CompileTimeBetterInstructionCollection
    {");
        foreach (AsmGenerationInfo asmGenerationInfo in asmGenerationInfos)
        {
            //TODO Write summary
            sb.AppendLine($"{indent}// <summary> </summary>");
            sb.AppendLine($"{indent}public static Assembler Parse(params AssemblyData[] assembly)");
            sb.AppendLine($"{indent}{{");

            GenerateAsmConverterMethodBody(context, sb, asmGenerationInfo, indent + "    ");

            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
        }

        sb.AppendLine(
            @"    }
}");
    }

    private static void GenerateAsmConverterMethodBody(GeneratorExecutionContext context, StringBuilder sb, AsmGenerationInfo asmGenerationInfo, string indent)
    {
        sb.AppendLine($"{indent}Assembler assembler = new(64);");
            
        foreach ((string? mnemonic, List<string>? operands) in asmGenerationInfo.InstructionLabels)
        {
            sb.AppendLine($"{indent}assembler.{mnemonic}({string.Join(", ", operands)});");
        }

        sb.AppendLine($"{indent}return assembler;");
    }
}