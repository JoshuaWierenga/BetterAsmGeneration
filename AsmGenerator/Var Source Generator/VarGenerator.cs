using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AsmGenerator.Var_Source_Generator;

//TODO 1. Skip AddVariables source generation and just store input for use with a AddInstructions
//TODO 2. Remove VariableAssembler and merge into Asm Source Generator
// requires making AddVariables just return the this Assembler
[Generator]
internal class VarGenerator : ISourceGenerator
{
    //TODO Use Register instead of AssemblyRegister{8, 16, 32, 64}?
    private const string VarGeneratorStub = @"
//<auto-generated />
using Iced.Intel;

namespace AsmGenerator
{
    internal static class VarGenerator
    {
        public static VariableAssembler AddVariables(this Assembler assembler, params VariableData[] variables)
        {
            // This will be filled in by the generator once you call it
            throw new Exception(""This shouldn't be possible."");
        }
    }
}
";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new VarSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not VarSyntaxReceiver syntaxReceiver)
        {
            throw new InvalidOperationException("We were given the wrong syntax receiver.");
        }

        List<ArgumentListSyntax> variableCalls = syntaxReceiver.VariableCalls;

        IEnumerable<VarGenerationInfo> varGenerationInfos =
            GetVarGenerationInfo(context.Compilation, variableCalls);

        if (varGenerationInfos.Any())
        {
            StringBuilder sb = new();
            GenerateVarContainerMethod(context, sb, varGenerationInfos);

            context.AddSource("VarConverter.cs", sb.ToString());
        }
        else
        {
            context.AddSource("VarConverter.cs", VarGeneratorStub);
        }
    }

    //TODO Support multiple AddVariable calls
    private static IEnumerable<VarGenerationInfo> GetVarGenerationInfo(Compilation compilation, 
        List<ArgumentListSyntax> variableCalls)
    {
        foreach (ArgumentListSyntax variableCallArguments in variableCalls)
        {
            List<Tuple<string, string, int>> variables = new();

            for (int i = 0; i < variableCallArguments.Arguments.Count; i++)
            {
                ArgumentSyntax argument = variableCallArguments.Arguments[i];
                string argumentString = argument.ToString().Replace(" ", "");
                string[] splitArgumentString = argumentString.Split('=');

                variables.Add(new Tuple<string, string, int>(splitArgumentString[0], splitArgumentString[1], i));
            }

            yield return new VarGenerationInfo(variables);
        }
    }

    private static void GenerateVarContainerMethod(GeneratorExecutionContext context, StringBuilder sb, 
        IEnumerable<VarGenerationInfo> varGenerationInfos)
    {
        const string indent = "        ";

        sb.AppendLine(
            @" // <auto-generated />
using Iced.Intel;
using static Iced.Intel.AssemblerRegisters;

namespace AsmGenerator
{
    internal static class VarGenerator
    {");

        GenerateVarWrapperMethod(context, sb, varGenerationInfos, indent);

        foreach (VarGenerationInfo varGenerationInfo in varGenerationInfos)
        {
            GenerateVarContainerMethod(context, sb, varGenerationInfo, indent);
        }

        sb.AppendLine(
            @"    }
}");
    }

    //TODO Write summary
    private static void GenerateVarWrapperMethod(GeneratorExecutionContext context, StringBuilder sb, 
        IEnumerable<VarGenerationInfo> varGenerationInfos, string indent)
    {
        sb.AppendLine($"{indent}// <summary> </summary>");
        sb.AppendLine($"{indent}public static VariableAssembler AddVariables(this Assembler assembler, params VariableData[] variables)");
        sb.AppendLine($"{indent}{{");

        GenerateVarWrapperMethodBody(context, sb, varGenerationInfos, indent + "    ");

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    //TODO Support multiple AddVariable calls
    private static void GenerateVarWrapperMethodBody(GeneratorExecutionContext context, StringBuilder sb, 
        IEnumerable<VarGenerationInfo> varGenerationInfos, string indent)
    {
        sb.AppendLine($"{indent}return AddVariablesSingleCall(assembler);");
    }

    //TODO Write summary
    //TODO Support multiple AddVariable calls
    private static void GenerateVarContainerMethod(GeneratorExecutionContext context, StringBuilder sb, 
        VarGenerationInfo varGenerationInfo, string indent)
    {
        sb.AppendLine($"{indent}// <summary> </summary>");
        sb.AppendLine($"{indent}private static VariableAssembler AddVariablesSingleCall(Assembler assembler)");
        sb.AppendLine($"{indent}{{");

        GenerateVarContainerMethodBody(context, sb, varGenerationInfo, indent + "    ");

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateVarContainerMethodBody(GeneratorExecutionContext context, StringBuilder sb, 
        VarGenerationInfo varGenerationInfo, string indent)
    {
        string insideIndent = indent + "    ";

        sb.AppendLine($"{indent}return new VariableAssembler(assembler,");
        sb.AppendLine($"{insideIndent}new Dictionary<string, VariableData>");
        sb.AppendLine($"{insideIndent}{{");

        GenerateVarContainerMethodBodyListBody(context, sb, varGenerationInfo, insideIndent + "    ");

        sb.AppendLine($"{insideIndent}}});");
    }

    private static void GenerateVarContainerMethodBodyListBody(GeneratorExecutionContext context, StringBuilder sb, 
        VarGenerationInfo varGenerationInfo, string indent)
    {
        //TODO Use position or remove
        foreach ((string variable, string register, int position) in varGenerationInfo.Variables)
        {
            sb.AppendLine($"{indent}{{\"{variable}\", {register}}},");
        }
    }
}
