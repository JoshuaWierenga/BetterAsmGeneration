#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AsmGenerator.Source_Generator;

[Generator]
public class AsmGenerator : ISourceGenerator
{
    private const string AsmGeneratorStub = @"
//<auto-generated />
using AsmGenerator;
using Iced.Intel;

namespace AsmGenerator
{
    internal static class CompileTimeBetterInstructionCollection
    {
        public static Assembler Parse(params AssemblyData[] assembly)
        {
            // This will be filled in by the generator once you call 
            throw new Exception(""This shouldn't be possible."");
        }
    }
}
";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
        {
            throw new InvalidOperationException("We were given the wrong syntax receiver.");
        }

        List<SyntaxNode> assemblerParseCalls = syntaxReceiver.AssemblerParseCalls;

        IEnumerable<AsmGenerationInfo> asmGenerationInfos =
            GetAsmGenerationInfo(context.Compilation, assemblerParseCalls);

        if (asmGenerationInfos.Any())
        {
            StringBuilder sb = new();
            GenerateAsmConverter(context, sb, asmGenerationInfos);

            context.AddSource("AsmConverter.cs", sb.ToString());
        }
        else
        {
            context.AddSource("AsmConverter.cs", AsmGeneratorStub);
        }
    }

    private static IEnumerable<AsmGenerationInfo> GetAsmGenerationInfo(Compilation compilation,
        List<SyntaxNode> assemblerParseCalls)
    {
        foreach (SyntaxNode assemblerParseCall in assemblerParseCalls)
        {
            //TODO Use data outside of invocation.ArgumentList or just return that from SyntaxReceiver
            InvocationExpressionSyntax invocation = (InvocationExpressionSyntax)assemblerParseCall;
            SemanticModel semanticModel = compilation.GetSemanticModel(invocation.ArgumentList.SyntaxTree);

            List<Tuple<string, List<string>>> instructionData = new(); 

            //TODO Remove
            //Debugger.Launch();

            foreach (ArgumentSyntax argument in invocation.ArgumentList.Arguments)
            {
                ExpressionSyntax asmData = argument.Expression;
                ITypeSymbol? typeSymbol = semanticModel.GetTypeInfo(asmData).Type;
                switch (asmData)
                {
                    case IdentifierNameSyntax identifier when typeSymbol?.Name == "Instruction":
                        string instructionLabel = identifier.Identifier.ValueText.ToLower();
                        instructionData.Add(
                            new Tuple<string, List<string>>(instructionLabel, new List<string>()));
                        break;
                    case IdentifierNameSyntax identifier when instructionData.Count > 0:
                        string operandLabel = identifier.Identifier.ValueText.ToLower();
                        instructionData.Last().Item2.Add(operandLabel);
                        break;
                    case LiteralExpressionSyntax literal when instructionData.Count > 0:
                        string literalValue = literal.Token.ValueText;
                        instructionData.Last().Item2.Add(literalValue);
                        break;
                    default:
                        //TODO Tidy!
                        throw new Exception();
                }
            }

            yield return new AsmGenerationInfo(instructionData);
        }
    }

    private static void GenerateAsmConverter(GeneratorExecutionContext context, StringBuilder sb,
        IEnumerable<AsmGenerationInfo> asmGenerationInfos)
    {
        const string indent = "        ";

        sb.AppendLine(
@" // <auto-generated />
using AsmGenerator;
using Iced.Intel;
using static Iced.Intel.AssemblerRegisters;

namespace AsmGenerator
{
    internal static class CompileTimeBetterInstructionCollection
    {");
        foreach (AsmGenerationInfo asmGenerationInfo in asmGenerationInfos)
        {
            //TODO Write summary
            sb.AppendLine($"{indent}// <summary> </summary>");
            sb.AppendLine($"{indent}public static Assembler Parse(params AssemblyData[] assembly)");
            sb.AppendLine($"{indent}{{");

            GenerateAsmConverterMethodBody(context, sb, asmGenerationInfo, indent + "    ");

            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
        }

        sb.AppendLine(
            @"    }
}");
    }

    private static void GenerateAsmConverterMethodBody(GeneratorExecutionContext context, StringBuilder sb, AsmGenerationInfo asmGenerationInfo, string indent)
    {
        sb.AppendLine($"{indent}Assembler assembler = new(64);");
            
        foreach ((string? mnemonic, List<string>? operands) in asmGenerationInfo.InstructionLabels)
        {
            sb.AppendLine($"{indent}assembler.{mnemonic}({string.Join(", ", operands)});");
        }

        sb.AppendLine($"{indent}return assembler;");
    }
}